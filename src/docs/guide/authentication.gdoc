The [authentication filter|http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/RestAuthenticationFilter.html]
uses the default @authenticationManager@ bean, which in turn uses all the registered authentication
providers. See the [Spring Security Core guide|http://grails-plugins.github.io/grails-spring-security-core/docs/manual/guide/authenticationProviders.html]
for more information about how to define your own providers. Note that you can easily plug any Spring Security sub-plugin
(like the LDAP one) to use a different authentication strategy.

If the authentication is successful, a [token generator|guide:tokenGeneration] is used to generate a token, and a
[token storage|guide:tokenStorage] implementation is used to store the token.

Finally, the JSON response sent back to the client is rendered by a @restAuthenticationTokenJsonRenderer@ bean. The plugin
offers you a [default implementation|http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/token/rendering/DefaultRestAuthenticationTokenJsonRenderer.html]
that renders a response like this:

{code}
{
    "username": "john.doe",
    "token": "1a2b3c4d",
    "roles": [
        "ADMIN",
        "USER"
    ]
}
{code}

This format can be customised with the following configuration keys:

{table}
*Config key*                                                                    | *Default value*
@grails.plugin.springsecurity.rest.token.rendering.usernamePropertyName@        | @username@
@grails.plugin.springsecurity.rest.token.rendering.tokenPropertyName@           | @token@
@grails.plugin.springsecurity.rest.token.rendering.authoritiesPropertyName@     | @roles@
{table}

{note}
When @rest.token.useBearerToken == true@ the @tokenPropertyName@ cannot be overridden, and will default to
@access_token@
{/note}

Eg, with the following configuration:

{code}
grails.plugin.springsecurity.rest.token.rendering.usernamePropertyName = 'login'
grails.plugin.springsecurity.rest.token.rendering.tokenPropertyName = 'access_token'
grails.plugin.springsecurity.rest.token.rendering.authoritiesPropertyName = 'permissions'
{code}

The output will look like:

{code}
{
    "login": "john.doe",
    "access_token": "1a2b3c4d",
    "permissions": [
        "ADMIN",
        "USER"
    ]
}
{code}

If you want your own, simply create a class implementing
[RestAuthenticationTokenJsonRenderer|http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/token/rendering/RestAuthenticationTokenJsonRenderer.html]
and wire it up in @resources.groovy@ with name @restAuthenticationTokenJsonRenderer@.

{note}
The principal object stored in the security context, and passed to the JSON renderer, is coming from the configured
authentication providers. In most cases, this will be a @UserDetails@ object retrieved using the @userDetailsService@ bean.
If you want to render additional information in your JSON response, you have to:
# Configure an alternative @userDetailsService@ bean that retrieves the additional information you want, and put it in a principal object.
# Configure an alternative @restAuthenticationTokenJsonRenderer@ that reads that information from the @restAuthenticationToken.principal@ object.
{note}

The following are the @Config.groovy@ properties available:

{table}
*Config key*                                                | *Default value*
@grails.plugin.springsecurity.rest.login.active@            | @true@
@grails.plugin.springsecurity.rest.login.endpointUrl@       | @/api/login@
@grails.plugin.springsecurity.rest.login.failureStatusCode@ | @401@
{table}

{note}
This authentication filter will only be applied to the above configured URL and can also be disabled, in case a different approach
for token creation is followed. In the rest of the cases, the request will continue through the filter chain, reaching Spring Security
Core filters. Bear in mind that, by default, Spring Security Core 2.x locks down all URL's unless a explicit securiy rule has been
specified for each of them.

See [Spring Security Core documentation|http://grails-plugins.github.io/grails-spring-security-core/docs/manual/guide/single.html#requestMappings]
for more information.
{note}

h2. Extracting credentials from the request

The plugin supports 2 ways of extracting the username and password: using request parameters, and using a JSON payload.
To align with the RESTful principles, JSON payload is the default behaviour.

h3. From a JSON request

{table}
*Config key*                                                    | *Default value*
@grails.plugin.springsecurity.rest.login.useJsonCredentials@    | @true@
@grails.plugin.springsecurity.rest.login.usernamePropertyName@  | @username@
@grails.plugin.springsecurity.rest.login.passwordPropertyName@  | @password@
{table}


The default implementation expects a request like this:

{code}
{
    "username": "john.doe",
    "password": "dontTellAnybody"
}
{code}

If you use @usernamePropertyName@ and @passwordPropertyName@ properties mentioned above, your JSON request can look like:

{code}
{
    "login": "john.doe",
    "pwd": "dontTellAnybody"
}
{code}

With the following config:

{code}
grails.plugin.springsecurity.rest.login.usernamePropertyName = 'login'
grails.plugin.springsecurity.rest.login.passwordPropertyName = 'pwd'
{code}

If your JSON request format is different, you can plug your own implementation by defining a class which extends
@[AbstractJsonPayloadCredentialsExtractor|http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/AbstractJsonPayloadCredentialsExtractor.html]@.
The default implementation looks like this:

{code}
@Slf4j
class DefaultJsonPayloadCredentialsExtractor extends AbstractJsonPayloadCredentialsExtractor {

    String usernamePropertyName
    String passwordPropertyName

    UsernamePasswordAuthenticationToken extractCredentials(HttpServletRequest httpServletRequest) {
        def jsonBody = getJsonBody(httpServletRequest)

        String username = jsonBody."${usernamePropertyName}"
        String password = jsonBody."${passwordPropertyName}"

        log.debug "Extracted credentials from JSON payload. Username: ${username}, password: ${password?.size()?'[PROTECTED]':'[MISSING]'}"

        new UsernamePasswordAuthenticationToken(username, password)
    }

}
{code}

Once you are done, register it in @resources.groovy@ with the name @credentialsExtractor@.

h3. From request parameters

Note that the name of the parameters can also be customised:

{table}
*Config key*                                                            | *Default value*
@grails.plugin.springsecurity.rest.login.useRequestParamsCredentials@   | @false@
@grails.plugin.springsecurity.rest.login.usernamePropertyName@          | @username@
@grails.plugin.springsecurity.rest.login.passwordPropertyName@          | @password@
{table}
